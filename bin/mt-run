#!/bin/bash


### Minetest Runner Usage:help
#
# Run a minetest server manually, with auto restart on failures.
#
# Usage:
#	mt-run [-d MTDIR]
#
# MTDIR is the path to the top level directory of a minetest installation. If omitted, uses the current working directory
#
# If the server stops or fails, it is immediately restarted -- this includes shutdowns from within the game with the /shutdown command
#
# If the server fails too quickly, the script will wait for a given number of seconds (default 60) before attempting to restart again.
# In this scenario, the admin will also receive an email if one is configured, containing the last few lines of the log file (default 100)
#
# The minetest.conf file is expected to live at the top of the MTDIR directory
#
# The MTDIR directory is expected to have a bin/ directory containing minetestserver, or for the binary to be configured in minetest.conf (see below)
#
###/doc

### Settings Usage:help
#
# minetest.conf can hold some extra values to configure mt-run
#
# 'mtrun.bin' -- the path to the minetest executable - for example, /usr/bin/minetestserver
#
# 'mtrun.failwait' -- the number of seconds to wait until restarting after a restart failure
#
# 'mtrun.failwindow' -- if server stops before <mtrun.failwindow> seconds have elapsed, consider it a server failure
#
# 'mtrun.email' -- the email address(es) of the person(s) to notify. Must be a space-separated list of email addresses
#
# 'mtrun.tail' -- the number of lines at the end of the failure log to include in the email
#
# 'mtrun.terminal' -- use ncurses terminal mode
#
###/doc

#!/bin/bash

### argument reader Usage:bbuild
# read arguments - tool for processing command line arguments
###/doc

declare -a ALLTHESCRIPTARGUMENTSAREHERE=("$@") # assign as an array
numpat='^[0-9]+$'

### Read argument Usage:bbuild
#
# Generalized argument reader function. (TODO - separate these into specialized functions)
#
#	argread [COUNT] TOKEN [YDEFAULT [NDEFAULT]]
#
# Locate a token, and read number of arguments after it.
#
# Tokens are output one per line
#
# If successful and COUNT is unspecified or zero, echoes YDEFAULT (default is empty string)
#
# If successful and COUNT is specified, echoes COUNT tokens after the sought token
#
# If unsuccessful, echo the value provided in DEFAULT to stdout (empty string by default, YDEFAULT must be specified)
#
# COUNT is by default zero.
#
# Where multiple instances exist, only the last instance will be returned
#
# examples:
#
# 	argread -y
# 		# returns 0 if '-y' is found in the arguments; returns 1 otherwise
#
# 	argread 2 -f
# 		# if -f is found, echoes the two tokens after it
#
# 	argread -r "" "./"
# 		# if -r is found, echoes nothing and returns 0; else echoes "./" and returns 1
#
# 	argread 1 -r "" "./"
# 		# if -r is found, echoes the next token and returns 0; else echoes "./" and returns 1; the empty string is ignored
# 
#
# Example uses:
#
#	if argread -y ; then
#		echo "yes"
#	fi
#
#	# assigns "/root" if "-r" is found
#	# else assigns "/home"
#	TARGETDIR="$(argread -r "/root" "/home" )"
#
#	MYDIR="$(argread 1 -f "" "./")"
#
# returns 0 on success, 1 otherwise
###/doc

function argread {
	local COUNT=0
	if [[ "$1" =~ $numpat ]]; then
		COUNT=$1 ; shift
	fi
	local TOKEN=$1 ; shift
	local YDEFAULT=
	local NDEFAULT=
	if [[ -n "$*" ]]; then
		YDEFAULT="$1"; shift
	fi
	if [[ -n "$*" ]]; then
		NDEFAULT="$1"; shift
	fi
	
	argread_inner "$COUNT" "$TOKEN" "$YDEFAULT" "$NDEFAULT" "${ALLTHESCRIPTARGUMENTSAREHERE[@]}" # that last one should still be an arry
}

### argread_inner Usage:bbuild
# do not use, internal only
###/doc
function argread_inner {
	local COUNT=$1 ; shift
	local TOKEN=$1 ; shift
	local YDEFAULT=$1 ; shift
	local NDEFAULT=$1 ; shift
	local gotarg=
	while [[ -n "$@" ]]; do
		ARG="$1"
		shift
		if [[ "$ARG" = "$TOKEN" ]]; then
			gotarg=
			if [[ "$COUNT" -le 0 ]]; then
				echo "$YDEFAULT"
				return 0
			fi
			for x in $(echo "{1..$COUNT}"); do
				gotarg="$gotarg$(echo -e "\n$1")" # first line will be empty
				shift
			done
		fi
		if [[ -z "$@" ]]; then # reached end, inside the while subroutine, must do this here
			if [[ -z "$gotarg" ]]; then
				echo "$NDEFAULT"
				return 1
			else
				echo "$gotarg"|sed '1 d' # delete first empty line
				return 0
			fi
		fi
	done

	return 1 # should never reach here
}
#!/bin/bash

### printhelp Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from a running script, call the
# `printhelp` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#	### <title> Usage:help
#	#
#	# <some content>
#	#
#	# end with "###/doc" on its own line (whitespaces before
#	# and after are OK)
#	#
#	###/doc
#
###/doc

CHAR='#'

function printhelp {
	USAGESTRING=help
	TARGETFILE=$0
	if [[ -n "$*" ]]; then USAGESTRING="$1" ; shift; fi
	if [[ -n "$*" ]]; then TARGETFILE="$1" ; shift; fi

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$CHAR$CHAR$CHAR"'\s+(.+?)\s+Usage:'"$USAGESTRING"'\s*$'
        local SECEND='^\s*'"$CHAR$CHAR$CHAR"'\s*/doc\s*$'
        local insec="$(mktemp --tmpdir)"; rm "$insec"
        cat "$TARGETFILE" | while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        touch "$insec"
                        echo -e "${BASH_REMATCH[1]}\n---\n"
                elif [[ -f $insec ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                rm "$insec"
                        else
				echo "$secline" | sed -r "s/^\s*$CHAR//g"
                        fi
                fi
        done
        if [[ -f "$insec" ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
		rm "$insec"
        fi
	echo ""
}

### automatic help Usage:bbuild
#
# automatically call help if "--help" is detected in arguments
#
###/doc
if [[ "$@" =~ --help ]]; then
	printhelp
	exit 0
fi
#!/bin/bash

### Key Value Pair Reader Usage:bbuild
#
# Read a value given the key, from a specified file
#
# Usage:
#
# 	readkv KEY FILE [DEFAULT]
#
# The KEY is the key in the file. A key is identified as starting at the beginning of a line, and ending at the first '=' character
#
# The value starts immediately after the first '=' character.
#
# If no value is found, the DEFAULT value is returned, or an empty string
#
###/doc

function readkv {
	thekey=$1 ; shift
	thefile=$1; shift
	thedefault=
	if [[ -n "${1+x}" ]]; then
		thedefault="$1"; shift
	fi

	res=$(egrep '^$thekey\s*=' "$thefile"|sed -r "s/^$thekey"'\s*'"=//")
	if [[ -z "$res" ]]; then
		echo "$thedefault"
	else
		echo "$res"
	fi
}

### freadkv - fail if no file exists Usage:bbuild
#
# Like readkv, but causes a hard failure if the file does not exist.
#
###/doc

function freadkv {
	if [[ -z "${2+x}" ]]; then
		faile "No file specified to read [$*]"
	fi
	if [[ ! -f "$2" ]] ; then
		faile "No such file $2 !"
	fi
	if ! head -n 1 "$2" > /dev/null; then
		faile "Could not read $2"
	fi
	readkv "$@"
}
#!/bin/bash

#!/bin/bash

export CDEF="[0m"
export CRED="[31m"
export CGRN="[32m"
export CYEL="[33m"
export CBLU="[34m"
export CBRED="[1;31m"
export CBGRN="[1;32m"
export CBYEL="[1;33m"
export CBBLU="[1;34m"

MODE_DEBUG=no

### debuge MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "yes"
###/doc
function debuge {
	if [[ "$MODE_DEBUG" = yes ]]; then
		echo -e "${CBBLU}DEBUG:$CBLU$*$CDEF" 1>&2
	fi
}

### infoe MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function infoe {
	echo -e "$CGRN$*$CDEF" 1>&2
}

### warne MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function warne {
	echo -e "${CBYEL}WARN:$CYEL $*$CDEF" 1>&2
}

### faile MESSAGE CODE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function faile {
	local MSG=
	local ARG=
	local ERCODE=127
	local numpat='^[0-9]+$'
	while [[ -n "$*" ]]; do
		ARG=$1 ; shift
		if [[ -z "$*" ]] && [[ "$ARG" =~ $numpat ]]; then
			ERCODE=$ARG
		else
			MSG="$MSG $ARG"
		fi
	done
	echo "${CBRED}ERROR FAIL:$CRED$MSG$CDEF" 1>&2
	exit "$ERCODE"
}

function dumpe {
	echo -n "[1;35m$*" 1>&2
	echo -n "[0;35m" 1>&2
	cat - 1>&2
	echo -n "[0m" 1>&2
}

if [[ "$*" =~ --debug ]]; then
	MODE_DEBUG=yes
fi

MTDIR=$(argread 1 -d )
if [[ -z "$MTDIR" ]]; then MTDIR=./ ; fi

CONFFILE="$MTDIR/minetest.conf"

MTBIN=$(freadkv mtrun.bin "$CONFFILE" "$MTDIR/bin/minetestserver")
RESTARTDELAY=$(freadkv mtrun.failwait "$CONFFILE" 60) # seconds to wait after a failure
ADMINEMAIL=$(freadkv mtrun.email "$CONFFILE" )
TAILLENGTH=$(freadkv mtrun.tail "$CONFFILE" 100)
TERMMODE=$(freadkv mtrun.terminal "$CONFFILE" "false")
FAILWINDOW=$(freadkv mtrun.failwindow "$CONFFILE" 15) # if server stops before $FAILWINDOW seconds have elapsed, consider it a server failure
SERVERNAME=$(freadkv "server_name" "$CONFFILE" "$HOSTNAME:$PWD")

TERMSTRING=""
if [[ "$TERMMODE" == "true" ]]; then TERMSTRING='--terminal'; fi

GRACE=2

mkdir -p "$MTDIR/logs"

while true; do
	d1=$(date "+%s")
	"$MTBIN" --config "$CONFFILE" --logfile "$MTDIR/logs"/debug.txt "$TERMSTRING"
	d2=$(date "+%s")
	ds=$(date "+%F%T"|sed -r 's/[^0-9]+/-/g')

	mv "$MTDIR/logs"/debug.txt "$MTDIR/logs"/minetest-"$ds".log

	infoe "========================= Log saved to $MTDIR/logs/minetest-$ds.log"

	if [[ "$(( $d2 - $d1 ))" -lt 15 ]]; then
		warne "RESTARTED TOO FAST - waiting $RESTARTDELAY seconds"
		if [[ -n "$ADMINEMAIL" ]]; then
			# do not quote admin email - could be several addresses
			tail -n $TAILLENGTH "$MTDIR/logs"/minetest-"$ds".log | mail -s "Minetest server failure [$SERVERNAME]" $ADMINEMAIL
		fi
		tail -n $TAILLENGTH "$MTDIR/logs"/minetest-"$ds".log
		sleep "$RESTARTDELAY" || faile "FAILED SLEEP - aborting" 
	else
		infoe "Restaring in $GRACE seconds"
		sleep $GRACE # grace period for proper interruption
	fi
done
